# Feature Request: Разработка единого сервиса игровой экономики


## 1. Предпосылки
Имеется несколько независимых игровых проектов (Project A, Project B и т.д.) на Unity (это толстые клиенты). Нужно разработать переиспользуемое решение, некий "черный ящик", который команды смогут интегрировать для работы с экономикой в контексте профилей пользователей, балансов валют и покупок.

## 2. Цель
Разработать архитектуру и API сервиса, который станет основой для игровой экономики и будет предоставляться продуктовым командам как C# библиотека (Unity Package). Сервис должен скрывать сложность сетевого взаимодействия и обеспечивать целостность данных.


## 3. Функциональные Требования

### 3.1. Работа с валютами и балансом
* **Универсальность:** Система должна поддерживать разные проекты. В одном проекте валюты могут называться "Золото", "Алмазы" и "Кристаллы", к примеру, в другом - "Коины", "Чеки" и "Кредиты".
* **Серверная конфигурация:** Список валют, их параметры и соотношения (цены - курсы обмена), задаются на сервере, их задает гейм-дизайнер/администратор проекта, через web-интерфейс, для которого также нужно разработать набор API методов, клиент получает их динамически.
* **Чтение баланса:** Клиент должен иметь возможность получить актуальный баланс всех валют игрока.
* **Обновления в реальном времени:** Баланс валют у игрока может меняться сервером (например, админ начислил бонус). Аналогично может быть изменен список валют, их параметры и соотношения. Клиент должен узнавать об этом и обновлять UI без перезахода в игру или явных действий пользователя.

### 3.2. Покупки (Транзакции)
* **Покупка - обмен валюи:** В данном случае под покупкой будет подразумеваться обмен одной валюты на другую по заданному курсу. Пример: 5 единиц валюты "Золото" можно обменять на 1 единицу "Алмазы", 10 единиц валюты "Алмазы" можно поменять на 1 единицу валюты "Кристаллы". Это можно описать как покупка 1 "Алмаза" за 5 "Золота" и как покупка 1 "Кристалла" за 10 "Алмазов", но по сути это обмен одной валюты на другую по заданным соотношениям.
  
* **Проверка на сервере (Server Authority):**
    * Клиент не должен присылать цену покупки в запросе.
    * Клиент не должен присылать свой новый баланс.
    * Сервер сам определяет стоимость и проверяет возможность покупки.

### 3.3. Жизненный цикл и Вход
* **"Бесшовный" вход:** Игрок не должен вводить логин/пароль при запуске игры.
* **Автоматическая регистрация:** Система должна сама регистрировать нового пользователя "на лету" при первом входе.
* **Восстановление сессии:** При перезапуске игры прогресс (баланс) должен сохраняться и восстанавливаться.

### 3.4. Администрирование (для Гейм-дизайнеров)
* Необходимо разработать API для настройки валют и товаров.
* Необходимо разработать API для начисления валюты конкретному игроку.

---

## 4. Нефункциональные Требования и Ограничения (NFR)

### 4.1. Масштабируемость и Нагрузка
* **Высокая одновременная нагрузка:** Ожидается 20.000+ игроков онлайн для одного игрового проекта.
* **Эффективность (обновлений):** Система должна доставлять изменения баланса клиенту в реальном времени без деградации производительности сервера при пиковых нагрузках.

### 4.2. Безопасность (Анти чит)
* **Защита от взлома памяти:** Система должна быть устойчива к инструментам типа ArtMoney.
* **Защита от подмены трафика:** Клиент не должен иметь возможности купить дорогой предмет за 1 монету, подменив пакет.

### 4.3. Поставка для команд разработки
* Команды получают Unity Package для интеграции в игровой проект.
* Им нужен простой C# интерфейс (API), чтобы они могли заниматься визуалом и геймплеем.
* Команды не должны вникать в сложность сетевого протокола, сокетов или баз данных.

---

## 5. Задача для Архитектора (системный дизайн)

На основе этих требований необходимо подготовить:
1.  **Верхнеуровневая архитектура:** Схема взаимодействия Клиент-Сервер.
2.  **Описание API:** Проект интерфейсов для C# SDK (IGameEconomyService) и серверного API (как минимум поставляемого разработчикам админки).
3.  **Флоу авторизации:** Решение проблемы безопасного "Тихого входа" и идентификации устройства.
4.  **модель данных:** Примерная модель данных для хранения балансов.
5.  **Структура проекта:** Описать структуру проекта с разделением по архитектурным слоям, указать как будет реализована инверсия зависимостей и где будет находиться бизнес-логика.
6.  **Обработка ошибок:** Разработать стратегию обработки ошибок

